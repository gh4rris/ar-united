// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSlugEvent = `-- name: CheckSlugEvent :one
SELECT COUNT(slug) AS slug_count
FROM events
WHERE slug = $1
`

func (q *Queries) CheckSlugEvent(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkSlugEvent, slug)
	var slug_count int64
	err := row.Scan(&slug_count)
	return slug_count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (id, name, location, date, created_at, updated_at, description, group_id, slug)
VALUES (
    gen_random_uuid(),
    $1,
    $2,
    $3,
    NOW(),
    NOW(),
    $4,
    $5,
    $6
)
RETURNING id, name, location, date, created_at, updated_at, description, group_id, slug
`

type CreateEventParams struct {
	Name        string
	Location    sql.NullString
	Date        time.Time
	Description sql.NullString
	GroupID     uuid.UUID
	Slug        string
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Name,
		arg.Location,
		arg.Date,
		arg.Description,
		arg.GroupID,
		arg.Slug,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.GroupID,
		&i.Slug,
	)
	return i, err
}

const eventGroup = `-- name: EventGroup :one
SELECT g.id, g.name, g.created_at, g.updated_at, g.admin_id, g.description, g.slug
FROM events AS e
INNER JOIN groups AS g
ON e.group_id = g.id
WHERE e.group_id = $1
`

func (q *Queries) EventGroup(ctx context.Context, groupID uuid.UUID) (Group, error) {
	row := q.db.QueryRowContext(ctx, eventGroup, groupID)
	var i Group
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdminID,
		&i.Description,
		&i.Slug,
	)
	return i, err
}

const eventsByAdmin = `-- name: EventsByAdmin :many
SELECT e.id, e.name, location, date, e.created_at, e.updated_at, e.description, group_id, e.slug, g.id, g.name, g.created_at, g.updated_at, admin_id, g.description, g.slug
FROM events AS e
INNER JOIN groups AS g
ON e.group_id = g.id
WHERE g.admin_id = $1
ORDER BY e.date ASC
`

type EventsByAdminRow struct {
	ID            uuid.UUID
	Name          string
	Location      sql.NullString
	Date          time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Description   sql.NullString
	GroupID       uuid.UUID
	Slug          string
	ID_2          uuid.UUID
	Name_2        string
	CreatedAt_2   time.Time
	UpdatedAt_2   time.Time
	AdminID       uuid.UUID
	Description_2 sql.NullString
	Slug_2        string
}

func (q *Queries) EventsByAdmin(ctx context.Context, adminID uuid.UUID) ([]EventsByAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, eventsByAdmin, adminID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventsByAdminRow
	for rows.Next() {
		var i EventsByAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.GroupID,
			&i.Slug,
			&i.ID_2,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.AdminID,
			&i.Description_2,
			&i.Slug_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventsByUser = `-- name: EventsByUser :many
SELECT e.id, e.name, e.location, e.date, e.created_at, e.updated_at, e.description, e.group_id, e.slug
FROM events AS e
INNER JOIN users_events AS ue
ON e.id = ue.event_id
WHERE ue.user_id = $1
ORDER BY e.date ASC
`

func (q *Queries) EventsByUser(ctx context.Context, userID uuid.UUID) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, eventsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.GroupID,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventBySlug = `-- name: GetEventBySlug :one
SELECT id, name, location, date, created_at, updated_at, description, group_id, slug
FROM events
WHERE slug = $1
`

func (q *Queries) GetEventBySlug(ctx context.Context, slug string) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEventBySlug, slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Location,
		&i.Date,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Description,
		&i.GroupID,
		&i.Slug,
	)
	return i, err
}

const searchEvents = `-- name: SearchEvents :many
SELECT id, name, location, date, created_at, updated_at, description, group_id, slug
FROM events
WHERE name ILIKE '%' || $1 || '%'
ORDER BY date ASC
`

func (q *Queries) SearchEvents(ctx context.Context, dollar_1 sql.NullString) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, searchEvents, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Location,
			&i.Date,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Description,
			&i.GroupID,
			&i.Slug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const usersByEvent = `-- name: UsersByEvent :many
SELECT u.id, u.first_name, u.last_name, u.dob, u.created_at, u.updated_at, u.email, u.bio, u.slug, u.profile_pic_url, u.hashed_password
FROM users_events AS ue
INNER JOIN users AS u
ON ue.user_id = u.id
WHERE ue.event_id = $1
ORDER BY u.first_name ASC
`

func (q *Queries) UsersByEvent(ctx context.Context, eventID uuid.UUID) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, usersByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Dob,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Bio,
			&i.Slug,
			&i.ProfilePicUrl,
			&i.HashedPassword,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
